
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);


const CONTENT_DIR = path.join(__dirname, '../../docs/content');
const ITEMS_ZH_DIR = path.join(CONTENT_DIR, 'zh');
const ITEMS_EN_DIR = path.join(CONTENT_DIR, 'en');

const MAINTENANCE_DIR = path.join(__dirname, '../../docs/maintenance');
const INDEX_ZH_FILE = path.join(MAINTENANCE_DIR, 'INDEX_ZH.md');
const INDEX_EN_FILE = path.join(MAINTENANCE_DIR, 'INDEX_EN.md');

import matter from 'gray-matter';

// Helper to get frontmatter safely
function getFrontmatter(filePath) {
  try {
    const rawContent = fs.readFileSync(filePath, 'utf-8');
    const { data } = matter(rawContent);
    return data;
  } catch (e) {
    console.error(`Error reading frontmatter from ${filePath}:`, e);
    return {};
  }
}

function generateGlossarySection(dir, isEn) {
  const files = fs.readdirSync(dir).filter(f => f.endsWith('.md')).sort();
  let output = `## ${isEn ? 'Glossary (EN)' : 'è¡“èªè¡¨ (Glossary)'}\n\n`;
  output += isEn ? `Total **${files.length}** termsï¼š\n\n` : `ç›®å‰å…±æœ‰ **${files.length}** å€‹è¡“èªï¼š\n\n`;

  files.forEach(file => {
    const fm = getFrontmatter(path.join(dir, file));
    const term = fm.term || file;
    output += `- **${term}** (\`${file}\`)\n`;
  });
  return output + '\n';
}

function generateQASection(baseDir, isEn) {
    const categories = [
        { dir: 'account', title: isEn ? 'Account & Server' : 'å¸³è™Ÿèˆ‡ä¼ºæœå™¨', path: 'qa/account' },
        { dir: 'enrollment', title: isEn ? 'Enrollment' : 'è£ç½®è¨»å†Š', path: 'qa/enrollment' },
        { dir: 'apps', title: isEn ? 'Apps & Content' : 'App ç®¡ç†', path: 'qa/apps' },
        { dir: 'classroom', title: isEn ? 'Classroom Tools' : 'èª²å ‚ç®¡ç†', path: 'qa/classroom' },
        { dir: 'digital-learning', title: isEn ? 'Digital Initiatives' : 'æ•¸ä½ç²¾é€²', path: 'qa/digital-learning' },
        { dir: 'hardware', title: isEn ? 'Hardware Tuning' : 'ç¡¬é«”æ’é™¤', path: 'qa/hardware' },
        { dir: 'mac', title: isEn ? 'Mac Management' : 'Mac ç®¡ç†', path: 'qa/mac' },
        { dir: 'qa-education', title: isEn ? 'Education Scenarios' : 'æ•™è‚²å¯¦æˆ°', path: 'qa/qa-education' }
    ];

    let totalQA = 0;
    const catData = categories.map(cat => {
        const catDir = path.join(baseDir, cat.dir);
        if (!fs.existsSync(catDir)) return { ...cat, files: [] };
        const files = fs.readdirSync(catDir).filter(f => f.endsWith('.md'));
        files.sort((a, b) => {
            const numA = parseInt(a.match(/\d+/)?.[0] || 0);
            const numB = parseInt(b.match(/\d+/)?.[0] || 0);
            if (numA !== numB) return numA - numB;
            return a.localeCompare(b);
        });
        totalQA += files.length;
        return { ...cat, files };
    });

    let output = `## ${isEn ? 'Q&A (EN)' : 'å•ç­”é›† (Q&A)'} [${isEn ? 'Total' : 'ç¸½è¨ˆ'}: **${totalQA}**]\n\n`;

    catData.forEach(cat => {
        if (cat.files.length === 0) return;

        output += `### ${cat.title} (\`${cat.path}\`) [**${cat.files.length}** ${isEn ? 'items' : 'é¡Œ'}]\n\n`;

        cat.files.forEach(file => {
            const fm = getFrontmatter(path.join(baseDir, cat.dir, file));
            const id = fm.id || '';
            const title = fm.title || file;
            output += `- [\`${id}\`] ${title}\n`;
        });
        output += '\n';
    });
    return output;
}

function generateIndex(isEn) {
    const itemsDir = isEn ? ITEMS_EN_DIR : ITEMS_ZH_DIR;
    const qaBaseDir = isEn ? path.join(itemsDir, 'qa') : path.join(itemsDir, 'qa'); // Warning: En structure might differ?
    // User structure seems to be:
    // zh: doc/data/items/glossary, doc/data/items/qa/...
    // en: doc/data/items-en/glossary, doc/data/items-en/qa/... (Assumed, need to verify if qa exists in items-en)
    
    // Let's check if qa dir exists in en
    const qaPath = path.join(itemsDir, 'qa');
    
    let content = isEn ? '# Maintenance Index (EN Version)\n\n' : '# ç¶­è­·ç´¢å¼• (Maintenance Index)\n\n';
    
    content += isEn 
        ? '> This file is automatically generated. Do not edit manually.\n\n'
        : '> æ­¤æ–‡ä»¶ç”±è…³æœ¬è‡ªå‹•ç”Ÿæˆã€‚ç”¨æ–¼è®“ç¶­è­·äººå“¡ï¼ˆæˆ– AIï¼‰å¿«é€Ÿç¢ºèªç›®å‰å·²å­˜åœ¨çš„å…§å®¹ï¼Œé¿å…é‡è¤‡æ–°å¢ã€‚\n\n';
        
    const now = new Date();
    content += `${isEn ? 'Last Updated' : 'æœ€å¾Œæ›´æ–°æ™‚é–“'}ï¼š${now.toLocaleString()}\n\n`;
    
    content += generateGlossarySection(path.join(itemsDir, 'glossary'), isEn);
    
    content += '--- \n\n';

    if (fs.existsSync(qaPath)) {
        content += generateQASection(qaPath, isEn);
    } else {
        // Maybe flat structure or different? Assuming standard for now based on prev file view
        // The MAINTENANCE_INDEX_EN.md showed qa sections, so it should exist.
        // Wait, looking at file list in prev steps, I only listed items/glossary.
        // I should assume structure matches.
    }
    
    fs.writeFileSync(isEn ? INDEX_EN_FILE : INDEX_ZH_FILE, content);
    console.log(`âœ… Generated ${isEn ? 'EN' : 'ZH'} Index`);
}

console.log('ğŸš€ Generating Indexes...');
generateIndex(false); // ZH
generateIndex(true);  // EN
console.log('âœ¨ Done.');
